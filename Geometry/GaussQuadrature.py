import numpy as np

class GaussQuadrature:
    """高斯积分点数据类，用于存储1D高斯积分的节点和权重"""
    
    # 预先计算的1D高斯积分点数据 (节点坐标, 权重)
    # 坐标范围在 [-1, 1], 权重和为2
    GAUSS_DATA = {
        1: {
            'points': [0.0],
            'weights': [2.0]
        },
        2: {
            'points': [-0.5773502691896257, 0.5773502691896257],
            'weights': [1.0, 1.0]
        },
        3: {
            'points': [-0.7745966692414834, 0.0, 0.7745966692414834],
            'weights': [0.5555555555555556, 0.8888888888888888, 0.5555555555555556]
        },
        4: {
            'points': [-0.8611363115940526, -0.3399810435848563, 0.3399810435848563, 0.8611363115940526],
            'weights': [0.3478548451374538, 0.6521451548625461, 0.6521451548625461, 0.3478548451374538]
        },
        5: {
            'points': [-0.9061798459386640, -0.5384693101056831, 0.0, 0.5384693101056831, 0.9061798459386640],
            'weights': [0.2369268850561891, 0.4786286704993665, 0.5688888888888889, 0.4786286704993665, 0.2369268850561891]
        },
        6: {
            'points': [-0.9324695142031521, -0.6612093864662645, -0.2386191860831969, 0.2386191860831969, 0.6612093864662645, 0.9324695142031521],
            'weights': [0.1713244923791704, 0.3607615730481386, 0.4679139345726910, 0.4679139345726910, 0.3607615730481386, 0.1713244923791704]
        },
        7: {
            'points': [-0.9491079123427585, -0.7415311855993945, -0.4058451513773972, 0.0, 0.4058451513773972, 0.7415311855993945, 0.9491079123427585],
            'weights': [0.1294849661688697, 0.2797053914892766, 0.3818300505051189, 0.4179591836734694, 0.3818300505051189, 0.2797053914892766, 0.1294849661688697]
        },
        8: {
            'points': [-0.9602898564975363, -0.7966664774136267, -0.5255324099163290, -0.1834346424956498, 0.1834346424956498, 0.5255324099163290, 0.7966664774136267, 0.9602898564975363],
            'weights': [0.1012285362903763, 0.2223810344533745, 0.3137066458778873, 0.3626837833783620, 0.3626837833783620, 0.3137066458778873, 0.2223810344533745, 0.1012285362903763]
        },
        9: {
            'points': [-0.9681602395076261, -0.8360311073266358, -0.6133714327005904, -0.3242534234038089, 0.0, 0.3242534234038089, 0.6133714327005904, 0.8360311073266358, 0.9681602395076261],
            'weights': [0.0812743883615744, 0.1806481606948574, 0.2606106964029354, 0.3123470770400029, 0.3302393550012598, 0.3123470770400029, 0.2606106964029354, 0.1806481606948574, 0.0812743883615744]
        },
        10: {
            'points': [-0.9739065285171717, -0.8650633666889845, -0.6794095682990244, -0.4333953941292472, -0.1488743389816312, 0.1488743389816312, 0.4333953941292472, 0.6794095682990244, 0.8650633666889845, 0.9739065285171717],
            'weights': [0.0666713443086881, 0.1494513491505806, 0.2190863625159820, 0.2692667193099963, 0.2955242247147529, 0.2955242247147529, 0.2692667193099963, 0.2190863625159820, 0.1494513491505806, 0.0666713443086881]
        }
    }
    
    @classmethod
    def get_1d_points_and_weights(cls, n):
        """获取n个点的1D高斯积分点和权重
        
        Args:
            n (int): 积分点数量 (1-10)
        
        Returns:
            tuple: (points, weights) 其中points和weights都是numpy数组
        """
        if n not in cls.GAUSS_DATA:
            raise ValueError(f"不支持的积分点数量: {n}，支持的数量为1-10")
        
        data = cls.GAUSS_DATA[n]
        return np.array(data['points']), np.array(data['weights'])
    
    @classmethod
    def get_2d_grid_points_and_weights(cls, n, dx):
        """获取2D网格单元内的高斯积分点位置和权重
        
        Args:
            n (int): 每个维度的积分点数量
            dx (float): 网格间距
        
        Returns:
            tuple: (positions, weights) 其中positions形状为(n*n, 2)，weights形状为(n*n,)
        """
        points_1d, weights_1d = cls.get_1d_points_and_weights(n)
        
        # 将1D点从[-1,1]映射到[-dx/2, dx/2]范围
        scaled_points_1d = points_1d * dx / 2.0
        
        # 生成2D笛卡尔积
        positions = []
        weights = []
        
        for i in range(n):
            for j in range(n):
                # 2D位置
                pos = [scaled_points_1d[i], scaled_points_1d[j]]
                positions.append(pos)
                
                # 2D权重是1D权重的乘积，需要缩放到正确的面积
                # 原始权重和为2，缩放到dx^2/4的面积
                weight = weights_1d[i] * weights_1d[j] * (dx * dx) / 4.0
                weights.append(weight)
        
        return np.array(positions), np.array(weights)
    
    @classmethod
    def is_perfect_square(cls, n):
        """检查一个数是否是完全平方数"""
        if n < 1:
            return False
        sqrt_n = int(n ** 0.5)
        return sqrt_n * sqrt_n == n
    
    @classmethod
    def get_sqrt_of_perfect_square(cls, n):
        """获取完全平方数的平方根"""
        if not cls.is_perfect_square(n):
            raise ValueError(f"{n} 不是完全平方数")
        return int(n ** 0.5)

    @classmethod
    def validate_particles_per_grid(cls, particles_per_grid):
        """验证particles_per_grid是否为支持的完全平方数"""
        if not cls.is_perfect_square(particles_per_grid):
            raise ValueError(f"使用高斯积分点摆放时，particles_per_grid必须是完全平方数，当前值: {particles_per_grid}")
        
        n = cls.get_sqrt_of_perfect_square(particles_per_grid)
        if n > 10:
            raise ValueError(f"高斯积分点数量不能超过10，当前需要: {n}")
        
        return n